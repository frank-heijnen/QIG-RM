\documentclass[11pt]{article}

% Packages
\usepackage{amsmath, amssymb}
\usepackage{geometry}
\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{minted}
\usepackage{natbib}
\geometry{margin=1in}

\begin{document}
\begin{titlepage}
  \centering
  \vspace*{2cm}
  \includegraphics[width=0.45\textwidth]{Pictures/Logo_TIC.png}\\[2cm]
  
  %--- Title ---
  {\Huge \textbf{A Backtesting Framework for Systematic Strategy Research}}\\[0.5cm]
  {\Large TIC's Quant Department -- Risk Management}\\[0.25cm]
  
  
  %--- Authors ---
  \textit{by}\\[0.75cm]
  {\large Ivan Khomyanin}\\
  {\large Bart van den Akker}\\
  {\large Huzaifa Bukhari}\\
  {\large Frank Heijnen}\\[2cm]
  
  \date{\today}
\end{titlepage}


\newpage

\begin{abstract}
This document outlines the architecture and rationale of a config-driven backtesting
framework designed for collaborative research in the Tilburg Investment Club.
The system separates strategy logic from backtest configuration, enabling reproducible
experiments, consistent execution, and scalable multi-strategy research. We describe
the data layer, strategy interface, configuration files, execution model, and overall
workflow.
\end{abstract}

\tableofcontents
\newpage

% Motivation section
\section{Motivation}

Collaborative research groups typically face the same recurring issues when multiple
members implement and test investment strategies:

\begin{itemize}
    \item Hard-coded parameters inside Python files lead to inconsistent results.
    \item Strategy code becomes entangled with data loading, execution rules, and dates.
    \item Experiments cannot be reproduced because configuration drift is untracked.
    \item Batch testing and walk-forward validation require manual edits to source code.
\end{itemize}

To solve these problems, we adopt a \textbf{config-driven architecture}, where all
strategy logic is written in Python, but the environment in which the strategy operates
is fully defined by external configuration files. This isolates the \textit{idea}
(strategy) from the \textit{experiment} (data, execution settings, dates).

% Section 2
\section{Separation of Code and Configuration}

The framework enforces a strict separation:

\begin{itemize}
    \item \textbf{Strategies}: implemented as Python classes with clearly defined inputs and outputs.
    \item \textbf{Configs}: YAML files specifying which strategy to run, over what data, using which execution and risk settings.
\end{itemize}

This design ensures the following:

\begin{itemize}
    \item The same strategy class can be tested under many environments without editing code.
    \item Every backtest run is fully reproducible by saving the configuration file.
    \item Parameter sweeps and sensitivity analyses are possible without code duplication.
    \item Framework updates do not break user strategies, and user strategies do not break the framework.
\end{itemize}

\newpage
% Section 3
\section{Folder Structure}

A clean folder structure enables multiple teams to work on the framework without conflicts:

\begin{verbatim}
QIG-RM/
    backtesting/
        strategies/
            <.py files containing a strategy>
        configs/
            <.yml files containing configurations>
    results/
        <auto-generated per run>
    backtesting_framework.py
    data_store.py
\end{verbatim}


% Section 4
\section{Strategy Interface}

Strategies are implemented in Python and produce deterministic signals.
Below is a minimal but representative interface:

\begin{minted}[fontsize=\small]{python}
class Strategy:
    def generate_signals(self, data):
        raise NotImplementedError
\end{minted}

A concrete example:

\begin{minted}[fontsize=\small]{python}
class MomentumStrategy(Strategy):
    def __init__(self, lookback, top_quantile, rebalance_frequency):
        self.lookback = lookback
        self.top_quantile = top_quantile
        self.rebalance_frequency = rebalance_frequency

    def generate_signals(self, data):
        returns = data["Close"].pct_change(self.lookback)
        ranks = returns.rank(axis=1, pct=True)
        long  = (ranks >= 1 - self.top_quantile).astype(int)
        short = (ranks <= self.top_quantile).astype(int) * -1
        return long + short
\end{minted}

Note that:
\begin{itemize}
    \item All parameters are passed at initialization.
    \item No dates, data paths, risk limits, or execution rules appear here.
    \item The class is usable with any config.
\end{itemize}

% Section 5
\section{Configuration Files (YAML)}

Configuration files define the environment in which a strategy is evaluated.

An example:

\begin{minted}[fontsize=\small]{yaml}
strategy:
  class: MomentumStrategy
  parameters:
    lookback: 60
    top_quantile: 0.2
    rebalance_frequency: "1M"

data:
  universe: "sp500"
  freq: "1D"
  source: "local_parquet"
  include_delisted: true

execution:
  slippage_bps: 3
  fees_bps: 1
  trade_at_open: true

risk:
  vol_target: 0.15
  max_leverage: 2.0

backtest:
  start: "2015-01-01"
  end: "2024-12-31"
  initial_capital: 1000000

output:
  path: "results/mom60/"
\end{minted}

The config file formally encodes:
\begin{itemize}
    \item \textbf{Which strategy class to run}
    \item \textbf{Which data universe and frequency to load}
    \item \textbf{Execution assumptions}: costs, slippage, trading rules
    \item \textbf{Risk overlays}: leverage, volatility targeting
    \item \textbf{Backtest horizon}
    \item \textbf{Output location}
\end{itemize}

Because of this structure, two backtests differ only by their config filesâ€”not by code.

\newpage
% Section 6
\section{Backtest Runner}

In the framework architecture used by the Tilburg Investment Club, 
the entire backtesting engine is implemented in a single file:
\texttt{backtesting/backtesting\_framework.py}. This file contains:

\begin{itemize}
    \item configuration loading and validation,
    \item strategy instantiation,
    \item data loading via a \texttt{DataStore} interface,
    \item execution and portfolio accounting,
    \item result logging and output generation.
\end{itemize}

The backtest runner follows three steps:

\begin{enumerate}
    \item Load the YAML configuration file.
    \item Dynamically import the strategy class from the \texttt{strategies/} directory.
    \item Execute the backtest using the shared framework logic.
\end{enumerate}

A minimal version of the runner is shown below:

\begin{minted}[fontsize=\small]{python}
# backtesting/backtesting_framework.py
import yaml
import importlib

from data_store import DataStore

class BacktestEngine:
    def __init__(self, config):
        self.cfg = config
        self.store = DataStore(config["data"])

    def run(self, strategy):
        data = self.store.load_universe(self.cfg["data"])
        signals = strategy.generate_signals(data)
        # execution + accounting logic here...
        return self._compute_results(signals, data)

def run_from_config(config_path):
    cfg = yaml.safe_load(open(config_path))

    module = importlib.import_module(
        f"backtesting.strategies.{cfg['strategy']['class'].lower()}"
    )
    StratClass = getattr(module, cfg["strategy"]["class"])
    strategy = StratClass(**cfg["strategy"]["parameters"])

    engine = BacktestEngine(cfg)
    return engine.run(strategy)

if __name__ == "__main__":
    import sys
    run_from_config(sys.argv[1])
\end{minted}

A backtest is launched using:

\begin{verbatim}
python backtesting/backtesting_framework.py configs/mom_60.yml
\end{verbatim}


% Section 7
\section{Data Layer Abstraction}

All data access is handled by a small file, \texttt{data\_store.py}, which provides a 
stable interface for loading market data regardless of where it is physically stored.
The group currently uses Parquet files synced through Google Drive, but the design 
allows seamless migration to SQL or cloud storage without modifying strategy code.

A simplified version of the abstraction:

\begin{minted}[fontsize=\small]{python}
# backtesting/data_store.py
import pandas as pd
from pathlib import Path

class DataStore:
    def __init__(self, cfg):
        self.root = Path(cfg["path"])

    def load_universe(self, cfg):
        universe = cfg["universe"]
        freq = cfg["freq"]
        folder = self.root / f"{universe}_{freq}"
        frames = [
            pd.read_parquet(folder / f"{asset}.parquet")
            for asset in cfg["assets"]
        ]
        return {a: f for a, f in zip(cfg["assets"], frames)}
\end{minted}

All strategies call data in the same way:

\begin{verbatim}
data = store.load_universe(cfg["data"])
\end{verbatim}

This removes user dependency on local file paths, storage backends, or metadata formats.

% Section 8
\section{Execution and Accounting}

The execution model and portfolio accounting logic are implemented directly inside
\texttt{backtesting\_framework.py}. While strategies only generate signals, the engine
determines how those signals translate into positions, trades, and P\&L.

The execution layer handles:
\begin{itemize}
    \item slippage and transaction cost assumptions,
    \item trade-at-open/close behavior,
    \item position sizing rules,
    \item rebalancing frequency,
    \item leverage constraints.
\end{itemize}

Accounting then computes:
\begin{itemize}
    \item daily returns,
    \item exposure and leverage,
    \item volatility, Sharpe ratio, and drawdowns,
    \item turnover and trading cost attribution.
\end{itemize}

Keeping execution and accounting in a single engine file makes the framework easier 
to maintain and ensures that all strategies share identical assumptions.

% Section 9
\section{Reproducibility and Experiment Logging}

Every backtest run produces a results folder containing:

\begin{itemize}
    \item a copy of the configuration file used,
    \item a small JSON with timestamps and framework version,
    \item performance metrics (Sharpe, drawdown, turnover),
    \item time series of portfolio value and exposures,
    \item strategy-level signals and trades (optional).
\end{itemize}

Because all parameters live in a standalone YAML configuration file, any experiment 
can be reproduced exactly by re-running the same config against the same version of 
the framework and data.

This structure ensures auditability, prevents configuration drift, and enables
parameter sweeps or walk-forward validation without editing strategy code.

% Section 10
\section{Conclusion}
The architecture used by the Tilburg Investment Club keeps the 
complexity low while preserving the essential features of a professional backtesting 
environment. A single engine file, a unified data interface, and external configuration 
files allow members to collaborate effectively without breaking each other's work.

As the number of strategies and users grows, the framework can be split into multiple 
files or modules, but the current layout strikes the ideal balance between clarity, 
flexibility, and reproducibility.

\bibliographystyle{apalike}
\bibliography{references}

\end{document}
